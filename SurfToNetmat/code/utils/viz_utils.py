import numpy as np
import matplotlib.pyplot as plt

def plot_training_losses(data, loss="MAE", range=np.arange(0,0.7, 0.05)):
    plt.plot(data, marker='.', linestyle='-')
    plt.yticks(range)
    plt.xlabel('Epoch')
    plt.ylabel(loss)
    plt.grid(True)
    plt.show()

def make_netmat(data, netmat_dim=100):

    # actually, this all testing so just need one such netmat I think. Since schf100 then one sub is (100*(100-1))/2 = 4950
    sing_sub = int((netmat_dim * (netmat_dim-1))/2)

    # get indeces of upptri cause all these vec netmats are upper trinagles. 
    out_mat_init = np.ones(2*sing_sub+netmat_dim).reshape(netmat_dim,netmat_dim)

    inds_uptri = np.triu_indices_from(out_mat_init,k=1) # k=1 means no diagonals
    inds_lowtri = np.tril_indices_from(out_mat_init,k=-1) # k=1 means no diagonal
    # print(len(inds_uptri), len(inds_uptri[0]), len(inds_uptri[1])) # make sure its same value as sing_sub above=n(n-1)/2
    # print(len(inds_lowtri), len(inds_lowtri[0]),len(inds_lowtri[1])) # make sure its same value as sing_sub above=n(n-1)/2
    out_mat_val = out_mat_init
    # out_mat_val[inds_uptri] = data
    out_mat_val[inds_lowtri] = data
    # Populate the upper triangle by transposing the lower triangle values
    out_mat_init[inds_uptri] = out_mat_init.T[inds_uptri]

    return out_mat_init

def show_netmats(data1, data2, netmat_dim=100):
    img1 = make_netmat(data1)
    img2 = make_netmat(data2)

    fig, axes = plt.subplots(1, 2, figsize=(11, 5))

    axes[0].imshow(img1, vmin=-1, vmax=1)
    axes[0].set_title('Ground Truth')
    axes[0].axis("off")

    plot2=axes[1].imshow(img2, vmin=-1, vmax=1)
    axes[1].set_title('Prediction')
    axes[1].axis("off")

    fig.colorbar(plot2)
    plt.tight_layout()

def show_subj_hemi(ground_truth_mat, pred_mat, subj_idx):
    ground_truth = ground_truth_mat[subj_idx, :]
    pred = pred_mat[subj_idx, :]
    print(f"Correlation: {np.corrcoef(ground_truth, pred)[0,1]}")
    show_netmats(ground_truth, pred)


def show_made_netmats(data1, data2, netmat_dim=100):
    fig, axes = plt.subplots(1, 2, figsize=(11, 5))

    axes[0].imshow(data1, vmin=-1, vmax=1)
    axes[0].set_title('Ground Truth')
    axes[0].axis("off")

    plot2=axes[1].imshow(data2, vmin=-1, vmax=1)
    axes[1].set_title('Sequentially Generated by Node (column)')
    axes[1].axis("off")

    fig.colorbar(plot2)
    plt.tight_layout()

def show_subj_hemi_made(ground_truth_mat, pred_mat, subj_idx, netmat_dim=100):

    ground_truth = ground_truth_mat[subj_idx, :, :]
    pred = pred_mat[subj_idx, :, :]

    corr_triu = np.corrcoef(ground_truth[np.triu_indices_from(ground_truth, k=1)], pred[np.triu_indices_from(pred, k=1)])[0,1]
    corr_tril = np.corrcoef(ground_truth[np.tril_indices_from(ground_truth, k=-1)], pred[np.tril_indices_from(pred, k=-1)])[0,1]

    print(f"Upper triangle correlation: {corr_triu}")
    print(f"Lower triangle correlation: {corr_tril}")

    show_made_netmats(ground_truth, pred, netmat_dim=netmat_dim)

def get_lower_tris(mat):
    trils = []
    for i in range(mat.shape[0]):
        tril = mat[i, :, :][np.tril_indices_from(mat[i, :, :], k=-1)]
        trils.append(tril)
    return np.array(trils)

def plot_traintest_losses_same_axes(train_losses, test_losses, loss="MSE"):
    """
    Plots the MSE losses from training and test set.

    Parameters:
    - train_losses: List of MSE values computed each epoch.
    - test_losses: List of MSE values computed every ten epochs.
    """

    # Generate epoch numbers for the training and test losses
    epochs = list(range(1, len(train_losses) + 1))
    test_epochs = [10 * i for i in range(0, len(test_losses))]

    # Plot the training losses
    plt.figure(figsize=(6, 4))
    plt.plot(epochs, train_losses, label=f'Train {loss}', marker=".")

    # Plot the test losses
    plt.plot(test_epochs, test_losses, label=f'Test {loss} (every 10 epochs)', color='red', marker='x')

    # Add labels and title
    plt.xlabel('Epochs')
    plt.ylabel(f'{loss}')
    plt.title(f'Training and Test {loss} Losses')
    plt.legend()
    plt.grid(True)
    plt.show()

def plot_traintest_losses_diff_axes(train_losses, test_losses, loss="Loss", test_range=None):
    """
    Plots the MSE losses from training and test set.

    Parameters:
    - train_losses: List of MSE values computed each epoch.
    - test_losses: List of MSE values computed every ten epochs.
    - loss: String indicating the type of loss (default is "MSE").
    """

    # Generate epoch numbers for the training and test losses
    epochs = list(range(0, len(train_losses)))
    test_epochs = [10 * i for i in range(0, len(test_losses))]

    # Create figure and axes
    fig, ax1 = plt.subplots(figsize=(8, 6))

    # Plot the training losses on ax1
    ax1.plot(epochs, train_losses, label=f'Train {loss}', marker=".")

    # Set labels and title for ax1
    ax1.set_xlabel('Epochs')
    ax1.set_ylabel(f'Train {loss}')
    ax1.set_title(f'Training and Test {loss} Losses')

    # Create a second y-axis sharing the same x-axis
    ax2 = ax1.twinx()

    # Plot the test losses on ax2
    ax2.plot(test_epochs, test_losses, label=f'Test {loss} (every 10 epochs)', marker='x', color='red')

    # Set label for ax2
    ax2.set_ylabel(f'Test {loss} (every 10 epochs)')

    if test_range is not None:
        ax2.set_yticks(test_range)

    # Combine legends from both axes
    lines, labels = ax1.get_legend_handles_labels()
    lines2, labels2 = ax2.get_legend_handles_labels()
    ax2.legend(lines + lines2, labels + labels2, loc='best')

    # Enable grid for both axes
    ax1.grid(True)

    # Show plot
    plt.show()

def plot_demeaned_corrs(train_corrs, test_corrs):
    epochs = list(range(1, len(train_corrs) + 1))

     # Plot the training losses
    plt.figure(figsize=(6, 4))
    plt.plot(epochs, train_corrs, label=f'Demeaned Train Corr', marker=".")

    # Plot the test losses
    plt.plot(epochs, test_corrs, label=f'Demeaned Test Corr', color='red', marker='x')

    # Add labels and title
    plt.xlabel('Epochs')
    plt.ylabel(f'Demeaned Corr')
    plt.yticks(np.arange(0, 1.1, 0.1))
    plt.legend()
    plt.grid(True)
    plt.show()